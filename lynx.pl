/***************************************************************************************************
  Lynx

	This file is part of Lynx
	http://www.di.uniba.it/~ndm/lynx/

	Copyright 2010-11 University of Bari "Aldo Moro"
	                                                                          
  Author: Nicola Di Mauro                                                 

	$Id: lynx.pl 29 2011-11-08 15:24:44Z ndm $

  $Rev: 29 $
  $Author: ndm $
  $Date: 2011-11-08 16:24:44 +0100 (mar, 08 nov 2011) $

 ***************************************************************************************************


 ***************************************************************************************************

  The Lynx Software is made available under the terms and conditions of the Artistic License 2.0.
  LICENSEE shall acknowledge University of Bari "Aldo Moro" as the provider of the Software.

 ***************************************************************************************************
	
Artistic License 2.0
[OSI Approved License]
Artistic License 2.0

Copyright (c) 2000-2006, The Perl Foundation.

Everyone is permitted to copy and distribute  verbatim copies of this license document, but changing
it is not allowed.

Preamble

This  license establishes  the  terms under  which  a given  free software  Package  may be  copied,
modified, distributed, and/or redistributed. The intent  is that the Copyright Holder maintains some
artistic control over the  development of that Package while still keeping  the Package available as
open source and free software.

You are  always permitted  to make  arrangements wholly outside  of this  license directly  with the
Copyright Holder of  a given Package. If the terms  of this license do not permit  the full use that
you propose  to make of the  Package, you should contact  the Copyright Holder and  seek a different
licensing arrangement.

Definitions

"Copyright Holder" means the individual(s) or  organization(s) named in the copyright notice for the
entire Package.

"Contributor"  means any  party that  has contributed  code  or other  material to  the Package,  in
accordance with the Copyright Holder's procedures.

"You" and "your" means any person who would like to copy, distribute, or modify the Package.

"Package" means the collection of files distributed by the Copyright Holder, and derivatives of that
collection and/or of those  files. A given Package may consist of either  the Standard Version, or a
Modified Version.

"Distribute" means providing a copy of the Package or making it accessible to anyone else, or in the
case of a company or organization, to others outside of your company or organization.

"Distributor Fee" means any  fee that you charge for Distributing this  Package or providing support
for this Package to another party. It does not mean licensing fees.

"Standard Version" refers to  the Package if it has not been modified, or  has been modified only in
ways explicitly requested by the Copyright Holder.

"Modified Version" means the  Package, if it has been changed, and  such changes were not explicitly
requested by the Copyright Holder.

"Original  License" means this  Artistic License  as Distributed  with the  Standard Version  of the
Package, in its current version or as it may be modified by The Perl Foundation in the future.

"Source" form means the source code, documentation source, and configuration files for the Package.

"Compiled" form means the  compiled bytecode, object code, binary, or any  other form resulting from
mechanical transformation or translation of the Source form.

Permission for Use and Modification Without Distribution

(1) You  are permitted  to use the  Standard Version and  create and  use Modified Versions  for any
purpose without restriction, provided that you do not Distribute the Modified Version.

Permissions for Redistribution of the Standard Version

(2) You may Distribute verbatim copies of the Source form of the Standard Version of this Package in
any medium without restriction, either gratis or  for a Distributor Fee, provided that you duplicate
all of the original copyright notices  and associated disclaimers. At your discretion, such verbatim
copies may or may not include a Compiled form of the Package.


(3) You may  apply any bug fixes,  portability changes, and other modifications  made available from
the Copyright Holder.  The resulting Package will  still be considered the Standard  Version, and as
such will be subject to the Original License.

Distribution of Modified Versions of the Package as Source

(4) You may Distribute your Modified Version as  Source (either gratis or for a Distributor Fee, and
with or without a  Compiled form of the Modified Version) provided that  you clearly document how it
differs  from the  Standard Version,  including, but  not limited  to, documenting  any non-standard
features, executables, or modules, and provided that you do at least ONE of the following:


(a) make the Modified  Version available to the Copyright Holder of  the Standard Version, under the
Original  License, so  that the  Copyright Holder  may include  your modifications  in  the Standard
Version.
(b)  ensure that  installation of  your Modified  Version does  not prevent  the user  installing or
running the Standard Version.  In addition, the Modified Version must bear  a name that is different
from the name of the Standard Version.
(c) allow anyone who receives a copy of the Modified Version to make the Source form of the Modified
Version available to others under

(i) the Original License or
(ii)  a license  that permits  the licensee  to freely  copy, modify  and redistribute  the Modified
Version  using the same  licensing terms  that apply  to the  copy that  the licensee  received, and
requires that  the Source form of the  Modified Version, and of  any works derived from  it, be made
freely available in that license fees are prohibited but Distributor Fees are allowed.

Distribution of Compiled Forms of the Standard Version or Modified Versions without the Source

(5) You may Distribute Compiled forms of  the Standard Version without the Source, provided that you
include complete instructions  on how to get  the Source of the Standard  Version. Such instructions
must be  valid at the time of  your distribution. If these  instructions, at any time  while you are
carrying out such distribution, become invalid, you must provide new instructions on demand or cease
further distribution.  If you provide  valid instructions or  cease distribution within  thirty days
after you become aware that the instructions are invalid, then you do not forfeit any of your rights
under this license.


(6) You  may Distribute a Modified  Version in Compiled form  without the Source,  provided that you
comply with Section 4 with respect to the Source of the Modified Version.

Aggregating or Linking the Package

(7) You  may aggregate  the Package  (either the Standard  Version or  Modified Version)  with other
packages and Distribute  the resulting aggregation provided  that you do not charge  a licensing fee
for the  Package. Distributor Fees  are permitted,  and licensing fees  for other components  in the
aggregation  are permitted. The  terms of  this license  apply to  the use  and Distribution  of the
Standard or Modified Versions as included in the aggregation.

(8) You are permitted to link Modified and  Standard Versions with other works, to embed the Package
in a larger  work of your own, or  to build stand-alone binary or bytecode  versions of applications
that include  the Package, and Distribute the  result without restriction, provided  the result does
not expose a direct interface to the Package.

Items That are Not Considered Part of a Modified Version

(9) Works (including, but not limited to, modules and scripts) that merely extend or make use of the
Package, do not, by themselves, cause the Package  to be a Modified Version. In addition, such works
are not considered parts of the Package itself, and are not subject to the terms of this license.

General Provisions

(10) Any  use, modification, and distribution  of the Standard  or Modified Versions is  governed by
this Artistic License. By using, modifying or  distributing the Package, you accept this license. Do
not use, modify, or distribute the Package, if you do not accept this license.

(11) If your  Modified Version has been derived  from a Modified Version made by  someone other than
you,  you  are  nevertheless required  to  ensure  that  your  Modified  Version complies  with  the
requirements of this license.

(12) This  license does not grant  you the right to  use any trademark, service  mark, tradename, or
logo of the Copyright Holder.

(13) This license includes the non-exclusive, worldwide, free-of-charge patent license to make, have
made, use, offer to sell, sell, import and otherwise transfer the Package with respect to any patent
claims licensable  by the Copyright  Holder that  are necessarily infringed  by the Package.  If you
institute patent  litigation (including  a cross-claim or  counterclaim) against any  party alleging
that the Package constitutes direct or  contributory patent infringement, then this Artistic License
to you shall terminate on the date that such litigation is filed.

(14) Disclaimer of  Warranty: THE PACKAGE IS  PROVIDED BY THE COPYRIGHT HOLDER  AND CONTRIBUTORS "AS
IS'  AND WITHOUT  ANY EXPRESS  OR  IMPLIED WARRANTIES.  THE IMPLIED  WARRANTIES OF  MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT ARE DISCLAIMED TO THE EXTENT PERMITTED BY YOUR
LOCAL LAW. UNLESS REQUIRED BY LAW, NO COPYRIGHT HOLDER OR CONTRIBUTOR WILL BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES ARISING  IN ANY WAY OUT  OF THE USE  OF THE PACKAGE,
EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

***************************************************************************************************/


/* ------------------------------------------------------------------------------------------- */ 	
:- module(lynx,[
  lynx_i/1,
  lynx_i/2,
  lynx_t/1,
  lynx_l/2,
  help/0,
  lynx_flags/0,
  '$models'/1
]).

:- load_foreign_files(['cgrasp'],[],init_my_predicates).

/* ============================================================================================
 *  YAP running options
 * ============================================================================================*/

:- yap_flag(unknown,fail).
:- yap_flag(discontiguous_warnings,on).
:- yap_flag(single_var_warnings,on).

%%% Debug options

%:- set_prolog_flag(profiling,on).
%:- set_prolog_flag(debug,on).


%%% No debug options

%:- set_prolog_flag(debug,off).
%:- set_prolog_flag(fast,on).

/* ============================================================================================
 *  Importing libraries 
 * ============================================================================================*/

:- use_module(library(lists)).
:- use_module(library(random)).
:- use_module(library(terms)).
:- use_module(library(system)).
:- use_module(library(ordsets)).

:- use_module('libs/utils').
:- use_module('libs/output').
:- use_module('libs/flags').
:- use_module('libs/confmatrix').
:- use_module('libs/prover').

/* ============================================================================================
 *  Dynamic predicates
 * ============================================================================================*/

:- dynamic mode/1.
:- dynamic type/1.

:- dynamic '$pattern_probabilities'/2.
:- dynamic '$models'/1.
:- dynamic covering/2.
:- dynamic '$classmodels'/2.
:- dynamic '$dimensionals'/1.
:- dynamic '$fluents'/1.
:- dynamic '$pattern'/2.
:- dynamic '$pclasses'/1.
:- dynamic key/1.
:- dynamic '$nofluents'/1.
:- dynamic maximalpatterns/1.
:- dynamic negconstraint/1.
:- dynamic numspecializations/1.
:- dynamic onlyone/1.
:- dynamic sametype/1.
:- dynamic values/2.
:- dynamic version/0.
:- dynamic dimension/1.
:- dynamic v/1.



/* ============================================================================================
 *  Global flags
 * ============================================================================================*/

lynx_version(1.2).
lynx_version_date('$Id: lynx.pl 29 2011-11-08 15:24:44Z ndm $').
lynx_manual('http://www.di.uniba.it/~ndm/lynx/').

/* ============================================================================================
 *  Main procedures
 * ============================================================================================*/

%%% Induce the model
lynx_i(X) :-
  lynx(X).


%%% Test the model
lynx_t(X) :-
  test(X).

%%% Induce and test the model
lynx_i(Train,Test) :-
  lynx(Train),
  test(Test).

%%% Load a classification model and then test the model
lynx_l(Model,Test) :-
  lynx_load(Model),
  test(Test).

lynx_load(InputFile) :-
  datime(datime(Year,Month,Day,Hours,Minutes,Seconds)),
  mktime(datime(Year,Month,Day,Hours,Minutes,Seconds),Seconds_elapsed),
  name(Seconds_elapsed,Seconds_elapsed_n0),
  append([.],Seconds_elapsed_n0,Seconds_elapsed_n),	
  set_lynx_flag('$problem_name',InputFile),
  atom_chars(InputFile,InputFileName),
  append(InputFileName,Seconds_elapsed_n,InputFileNameSecs),
  append(InputFileNameSecs,[.,o,u,t],InputFileName0),
  atom_chars(OutFile,InputFileName0),
  set_lynx_flag('$output_file_name',OutFile),
  append(InputFileName,[.,m,o,d,e,l],CMFileName0),
  append(InputFileName,[.,b,k],BKFileName0),
  append(InputFileName,[.,l],LangFileName0),	
  append(InputFileName,[.,c,l,a,s,s,i,f,i,c,a,t,i,o,n],SFileName0),	
  atom_chars(BKFileName,BKFileName0),
  atom_chars(LangFileName,LangFileName0),
  atom_chars(SFileName,SFileName0),
  atom_chars(CMFileName,CMFileName0),
  set_lynx_flag('$classification_file_name',SFileName),
  open(OutFile,write,StreamOut),

  set_lynx_flag('$fileout',StreamOut),
  set_lynx_flag('$bkfilename',BKFileName),

  consult(LangFileName),	
  consult(CMFileName),
  set_all_auc_filenames,

  close(StreamOut).

  

%%% Display help 
help :-
  format("~n----------------------------------------------------------------~n",[]),
  format('~n Commands:~2n',[]),
  format('   lynx_i(TRAINFILE).                   perform learning on TRAINFILE~n',[]),
  format('   lynx_i(TRAINFILE,TESTFILE).          perform learning on TRAINFILE and test on TESTFILE~n',[]),
  format('   lynx_t(TESTFILE).                    test on TESTFILE~n',[]),	
  format('   lynx_l(MODELFILE,TESTFILE).          load a classification model from MODELFILE and then test on TESTFILE~n',[]),	
  format('   lynx_flags.                          shows all settings~n',[]),
  format('   get_lynx_flag(FLAG,VALUE).           get current VALUE for FLAG~n',[]),
  format('   set_lynx_flag(FLAG,VALUE).           set VALUE for FLAG~n',[]),
  format('   halt.                                quit Yap~n',[]),
  format('   help.                                shows this help~n',[]),
  format('~2n',[]).

%%% Display menu
menu :-
  version,
  format("~2n----------------------------------------------------------------",[]),
  format("\nLynx\n",[]),
  lynx_version(Version),
  format("Version ~w\n",[Version]),
  lynx_version_date(Date),
  format("Last modified: ~w\nAuthor: Nicola Di Mauro~2n",[Date]),
  lynx_manual(Man),
  format("Manual: ~w",[Man]),
  help.

%%% main inductive loop
lynx(InputFile) :-
  datime(datime(Year,Month,Day,Hours,Minutes,Seconds)),
  mktime(datime(Year,Month,Day,Hours,Minutes,Seconds),Seconds_elapsed),
  name(Seconds_elapsed,Seconds_elapsed_n0),
  append([.],Seconds_elapsed_n0,Seconds_elapsed_n),	
  set_lynx_flag('$problem_name',InputFile),
  atom_chars(InputFile,InputFileName),
  append(InputFileName,Seconds_elapsed_n,InputFileNameSecs),
  append(InputFileNameSecs,[.,o,u,t],InputFileName0),

  atom_chars(OutFile,InputFileName0),
  set_lynx_flag('$output_file_name',OutFile),

  append(InputFileName,[.,b,k],BKFileName0),
  append(InputFileName,[.,m,o,d,e,l],CMFileName0),
  append(InputFileName,[.,m],ModelsFileName0),
  append(InputFileName,[.,l],LangFileName0),	
  append(InputFileName,[.,c,l,a,s,s,i,f,i,c,a,t,i,o,n],SFileName0),	
  atom_chars(BKFileName,BKFileName0),
  atom_chars(CMFileName,CMFileName0),
  atom_chars(ModelsFileName,ModelsFileName0),
  atom_chars(LangFileName,LangFileName0),
  atom_chars(SFileName,SFileName0),
  set_lynx_flag('$classification_file_name',SFileName),
  open(SFileName,write,SSS),
  close(SSS),

  open(OutFile,write,StreamOut),

  set_lynx_flag('$fileout',StreamOut),
  set_lynx_flag('$bkfilename',BKFileName),

  datime(datime(Year,Month,Day,Hour,Minute,Seconds)),
  format_outfile("Executed ~w.~w.~w ~w:~w:~w~n",[Day,Month,Year,Hour,Minute,Seconds]),

  consult_models(ModelsFileName,Models),
  load_bk_in_module(BKFileName,models),
  assert('$models'(Models)),
  assert_classes(Models),
  assert_covering(Models),

  consult(LangFileName),	

  lynx_flags,
  lynx_flags(StreamOut),

  print_num_models(Models),

  set_all_auc_filenames,

  findall(P2, type(P2), Types),
  predicate_type(Types, Fluent, NoFluent),
  assert('$fluents'(Fluent)),
  assert('$nofluents'(NoFluent)),
  dimensional_predicates(Dimensional),
  assert('$dimensionals'(Dimensional)),

  format("~nSequential data settings~n",[]),
  format("========================~n",[]),
  format("  Fluent predicates:      ~w~n",[Fluent]),
  format("  NoFluent predicates:    ~w~n",[NoFluent]),
  format("  Dimensional predicates: ~w~n",[Dimensional]),

  format_outfile("~nSequential data settings~n",[]),
  format_outfile("========================~n",[]),
  format_outfile("  Fluent predicates:      ~w~n",[Fluent]),
  format_outfile("  NoFluent predicates:    ~w~n",[NoFluent]),
  format_outfile("  Dimensional predicates: ~w~n",[Dimensional]),

  create_initial_patterns(Fluent,InitalPatterns),
  length(InitalPatterns,Level0),

  format("~nStarting features: ~w~n",[Level0]),
  format(" Calculating frequencies...~n",[]),
  format_outfile("Starting features: ~w~n",[Level0]),
  format_outfile(" Calculating frequencies...~n",[]),

  initial_patterns_frequencies(InitalPatterns,InitalPatternsFreq0),!,

  get_lynx_flag('$minfreq',MinFreq),
  get_lynx_flag('$minclassrecall', MinClRec),

  format(" Removing infrequent... ",[]),
  format_outfile(" Removing infrequent... ",[]),	

  remove_low_freq(InitalPatternsFreq0,MinFreq,MinClRec,InitalPatternsFreq),
  length(InitalPatternsFreq,LLL),write(LLL),

  T0 is cputime,
  assert(maximalpatterns(0)),

  assert(numspecializations(0)),	
  lynx(InitalPatternsFreq,1),
  T1 is cputime,
  T is T1 - T0,

  format("~nLYNX Time ~w~n",[T]),
  format_outfile("~nLYNX Time ~w~n",[T]),	

  set_patterns_probabilities,
  assert_pclasses,
  compute_seqprob,

  grasp,

  statistics,

  maximalpatterns(MaximalPatterns),
  retract(numspecializations(NumSpecs)),	
  write('\n\nMaximal Features: '),
  write(MaximalPatterns),
  write('\nTotal specializations: '),
  write(NumSpecs),nl,
  statistics(cputime,[CpuTime,_]), CpuTime1 is CpuTime / 1000,
  statistics(runtime,[RunTime,_]), RunTime1 is RunTime / 1000,
  statistics(walltime,[WallTime,_]), WallTime1 is WallTime / 1000,
  print_line(StreamOut),
  format_outfile("~nStatistics~n",[]),
  format_outfile("~t~3f~12+ sec. runtime~n", [RunTime1]),
  format_outfile("~t~3f~12+ sec. cputime~n", [CpuTime1]),
  format_outfile("~t~3f~12+ sec. elapsed time~n", [WallTime1]),
  format_outfile("~t~3f~12+ sec. LYNX time~n~n", [T]),
  close(StreamOut),


  /* saving the model */ 
  open(CMFileName,write,MSout),
  open_comment_line(MSout),
  format(MSout,"Classification model created ~w/~w/~w ~w:~w:~w~n",[Day,Month,Year,Hour,Minutes,Seconds]),
  close_comment_line(MSout),
  get_lynx_flag('$classes',CMclasses),
  format(MSout,":-set_lynx_flag('$classes',~w).~n",[CMclasses]),
  format(MSout,"maximalpatterns(~w).~n",[MaximalPatterns]),
  '$pclasses'(CMpclasses),
  format(MSout,"'$pclasses'(~w).~n",[CMpclasses]),
  save_class_model(MSout,MaximalPatterns),
  close(MSout).


save_class_model(MSout,0):-
	!.
save_class_model(MSout,N):-
  	'$pattern'(N,Pattern),
  	'$pattern_probabilities'(N,Val),
	format(MSout,"'$pattern'(~w,",[N]),
	portraylist(MSout,Pattern),
	format(MSout,").~n",[]),
	format(MSout,"'$pattern_probabilities'(~w,~w).~n",[N,Val]),
	N1 is N -1,
	save_class_model(MSout,N1).

print_num_models(Models):-
  length(Models,L),
  format("~nClasses: ~w",[L]),
  format_outfile("~nClasses: ~w",[L]),	
  print_num_models1(Models).
print_num_models1([]).
print_num_models1([[Class,Models]|R]):-
  length(Models,L),
  format("~n  ~w: ~w models",[Class,L]),
  format_outfile("~n  ~w: ~w models",[Class,L]),	
  print_num_models1(R).

lynx([],_) :-
  !,
  nl,write('No more features'),nl.

lynx(Patterns,Step) :-
  get_lynx_flag('$fileout',StreamOut),
  format("~2n=== [LEVEL ~w] === ~n Specializing...",[Step]),
  format(StreamOut,"~2n=== [LEVEL ~w] ===",[Step]),
  flush_output,
  /* specialize the features */
  specialize(Patterns,SpecPatterns000),
  /* remove empty features */
  remove_empty(SpecPatterns000,SpecPatterns00),
  length(SpecPatterns00,LSpecPatterns0),
  format(" ~w",[LSpecPatterns0]),
  format(StreamOut,"\nSpecializations ~w~n",[LSpecPatterns0]),
  flush_output,
  retract(numspecializations(OldNumSpecs)),
  NewNumSpecs is OldNumSpecs + LSpecPatterns0,
  assert(numspecializations(NewNumSpecs)),

  SpecPatternsFreqFF0 = SpecPatterns00,

  get_lynx_flag('$minfreq',MinFreq),
  get_lynx_flag('$minclassrecall', MinClRec),
  nl,write(' Removing infrequent...'),flush_output,
  /* remove non frequent features */
  remove_low_freq(SpecPatternsFreqFF0,MinFreq,MinClRec,SpecPatternsFreq1111),
  length(SpecPatternsFreq1111,LSpecPatternsFreq1111),
  write(' '),write(LSpecPatternsFreq1111),flush_output,

  /* è possibile eliminare tutti i pattern p più generali di p' frequenti sulle stesse sequenze */
  nl,write(' Removing general ...'),flush_output,	
  remove_general(SpecPatternsFreq1111,SpecPatternsFreq111),
  length(SpecPatternsFreq111,LSpecPatternsFreqAA0),
  write(' '),write(LSpecPatternsFreqAA0),flush_output,

  nl,write(' Saving contrasting features...'),flush_output,
  save_contrasting_patterns(SpecPatternsFreq111),

  get_lynx_flag('$mincover', MinCov),
  nl,write(' Removing mincovered...'),flush_output,
  /* rimuove i pattern non frequenti */
  remove_min_cov(SpecPatternsFreq111,MinCov,SpecPatternsFreq1),
  length(SpecPatternsFreq1,LSpecPatternsFreq1),
  write(' '),write(LSpecPatternsFreq1),flush_output,

  get_lynx_flag('$maxsize',MaxSize),
  nl,write(' Saving maximals...'),flush_output,
  /* salva i pattern massimali */
  remove_max_length(SpecPatternsFreq1,MaxSize,SpecPatternsFreq4),
  length(SpecPatternsFreq4,LSpecPatternsFreq2),
  write(' '),write(LSpecPatternsFreq2),flush_output,
  write(StreamOut,'\nTaken '),write(StreamOut,LSpecPatternsFreq2),

  SpecPatternsFreq5 = SpecPatternsFreq4,

  (LSpecPatternsFreq2 == 0
  ->
    true
  ;
    Step1 is Step + 1,
    lynx(SpecPatternsFreq5,Step1)
  ).


/* ============================================================================================
*  Computing the a priori probabilities of the examples 
*  ============================================================================================*/

%%% compute sequence probabilities
compute_seqprob :-
  nl,write('Computing models probabilities'),flush_output,
  maximalpatterns(NumPatterns),
  NumPatterns1 is NumPatterns + 1,
  create_arrays_seqpat(NumPatterns1),
  compute_seqprob(NumPatterns),
  write('!'),flush_output.

compute_seqprob(0):-
  !.
compute_seqprob(N):-
  N1 is N - 1,
  compute_seqprob(N1),
  '$pattern'(N,[_Pattern,Classes]),
  '$pattern_probabilities'(N,Val),
  '$models'(Models),
  extract_models_from_pattern(Classes,ModelsP),
  compute_seqprob1(Models,ModelsP,[N,Val]).

compute_seqprob1([],_,_).
compute_seqprob1([[_Class,Models]|RestModels],ModelsP,[N,Val]):-
  compute_seqprob1(RestModels,ModelsP,[N,Val]),
  compute_seqprob2(Models,ModelsP,[N,Val]).

compute_seqprob2([],_,_).
compute_seqprob2([Model|RestModels],ModelsP,[N,Val]):-
  compute_seqprob2(RestModels,ModelsP,[N,Val]),	
  (member(Model,ModelsP) ->
    X = 1
  ;
    X = 0
  ),
  compute_cond_prob([X-Val],Prob),
  update_array(Model, N, Prob).

compute_cond_prob([X-Val],Prob):-
  compute_cond_prob1(Val,X,Prob).
compute_cond_prob1([],_X,[]).
compute_cond_prob1([P|RP],X,[P1|RP1]):-
  ( X == 0
  ->
    P1 is 1 - P
  ;
    P1 is P
  ),
  compute_cond_prob1(RP,X,RP1).


%%% recompute sequence probabilities
recompute_seqprob :-
  %nl,write('Re-computing models probabilities'),flush_output,
  maximalpatterns(NumPatterns),
  close_arrays_seqpat,
  NumPatterns1 is NumPatterns + 1,	
  create_arrays_seqpat(NumPatterns1),	
  compute_seqprob(NumPatterns),
  write('!'),nl,nl,flush_output.

/* ============================================================================================
*  Array models-patterns  
*  ============================================================================================*/

create_arrays_seqpat(N):-
  '$models'(Models),
  create_arrays_seqpat(Models,N).
create_arrays_seqpat([],_).
create_arrays_seqpat([[_Class,Models]|RestModels],N):-
  create_arrays_seqpat(RestModels,N),
  create_arrays_seqpat1(Models,N).	
create_arrays_seqpat1([],_).
create_arrays_seqpat1([M|R],N):-
  create_arrays_seqpat1(R,N),
  static_array(M,N,term).

close_arrays_seqpat:-
  '$models'(Models),
  close_arrays_seqpat(Models).
close_arrays_seqpat([]).
close_arrays_seqpat([[_Class,Models]|RestModels]):-
  close_arrays_seqpat(RestModels),
  close_arrays_seqpat1(Models).	
close_arrays_seqpat1([]).
close_arrays_seqpat1([M|R]):-
  close_arrays_seqpat1(R),
  close_static_array(M).

/* ============================================================================================
*    
*  ============================================================================================*/

extract_models_from_pattern([],[]).
extract_models_from_pattern([[_,_,_,ModelsP]|Classes],ModelsP1):-
  extract_models_from_pattern(Classes,ModelsP2),
  append(ModelsP,ModelsP2,ModelsP1).

/* ============================================================================================
*    
*  ============================================================================================*/

assert_pclasses :-
  '$models'(Models),
  (get_lynx_flag('$unbalanced_data',true) ->
    get_lynx_flag('$classes',Classes),
    length(Classes,Num_classes),
    equal_probs(Num_classes, Class_probs),
    assert('$pclasses'(Class_probs))
  ;
    count_total_models(Models,TotMod),  
    class_probabilities(Models,TotMod,T3),
    assert('$pclasses'(T3))
  ).

equal_probs(Num_classes, Probs) :-
  equal_probs(0, Num_classes, Probs).
equal_probs(K, K, []) :- 
  !.
equal_probs(K, Num_classes, [Class_prob|Rest_c_p]):-
  K1 is K + 1,
  equal_probs(K1, Num_classes, Rest_c_p),
  Class_prob is 1.0 / Num_classes.

class_probabilities([],_,[]).
class_probabilities([[_,M]|R],T,[V|RV]):-
  length(M,LM),
  V is LM/T,
  class_probabilities(R,T,RV).

/* ============================================================================================
*  GRASP optimization step
*
*  The set of all the generated patterns are considered to find a subset optimizing the 
*  likelihood of the sequences.
*  ============================================================================================*/

grasp:-
  maximalpatterns(NumPatterns),
  make_numeric_list(1,NumPatterns,NeighborsElements),
  compute_uncorrectly_classified_models(NeighborsElements,Error),
  get_lynx_flag('$classification_file_name',SFileName),			
  open(SFileName,'append',SSS),
	format(SSS,"~n Errors: ~w",[Error]),	
	close(SSS),		
  write(' Errors: '),write(Error),nl,
  grasp(NeighborsElements,Solution,200,0.1),
  format("~n",[]),
  compute_uncorrectly_classified_models(Solution,Error1),
  format(" Errors: ~w",[Error1]),
  open(SFileName,'append',SSS1),
	format(SSS1,"~n Errors: ~w",[Error1]),
	close(SSS1),		
  reset_patterns_probabilities,
  recompute_seqprob.

grasp(Patterns,Solution,MaxIter,Alpha):-

  maximalpatterns(NumPatterns),
  '$models'(Models),
  count_seq(Models,NumSequences),
  get_lynx_flag('$classes',Classes),
  length(Classes,NumClasses),

  write('\nComputing Matrix'),flush_output,
  compute_matrix_cgrasp(Models,NumPatterns,Matrix),
  write('!'),flush_output,
  '$pclasses'(ProbClasses),
  cgrasp(NumPatterns,NumClasses,NumSequences,Matrix,ProbClasses,MaxIter,Alpha,Solution),
  length(Solution,L),
  retract(maximalpatterns(NumPatterns)),
  assert(maximalpatterns(L)),
  nl,write('Taking '),write(L),write('/'),write(NumPatterns),write(' features'),
  remove_bad_patterns(Patterns,Solution),
  assert_new_patterns(Solution,1).

compute_matrix_cgrasp([],_NumPatterns,[]).
compute_matrix_cgrasp([[_C,M]|R],NumPatterns,[Matrix1|RestMatrix]):-
  compute_matrix_cgrasp1(M,NumPatterns,Matrix1),
  compute_matrix_cgrasp(R,NumPatterns,RestMatrix).
compute_matrix_cgrasp1([],_NumPatterns,[]).
compute_matrix_cgrasp1([M|R],NumPatterns,Matrix):-
  compute_matrix_cgrasp2(M,1,NumPatterns,Matrix0),
  compute_matrix_cgrasp1(R,NumPatterns,Matrix1),
  %	nl,write(Matrix0),flush_output,
  append(Matrix0,Matrix1,Matrix).
compute_matrix_cgrasp2(M,K,NumPatterns,[Prob|RP]):-
  K =< NumPatterns,	
  %	'$seqpatsc'(M,K,Prob),
  array_element(M, K, Prob),
  %nl,write(M),write(' '),write(K),write(' '),write(Prob),flush_output,
  !,
  K1 is K + 1,
  compute_matrix_cgrasp2(M,K1,NumPatterns,RP).
compute_matrix_cgrasp2(_M,_K,_NumPatterns,[]).

count_seq([],0).
count_seq([[_,S]|R],D):-
  count_seq(R,D1),
  length(S,L1),
  D is L1 + D1.

assert_new_patterns([],_).
assert_new_patterns([P|R],K):-
  retract('$pattern'(P,[Pattern,Classes])),!,
  assert('$pattern'(K,[Pattern,Classes])),
  nl, portraylist(Pattern),write_freq_pattern2(Classes)	,
  K1 is K + 1,
  assert_new_patterns(R,K1).

remove_bad_patterns([],_).
remove_bad_patterns([P|R],Solution) :-
  member(P,Solution),
  !,
  remove_bad_patterns(R,Solution).
remove_bad_patterns([P|R],Solution) :-		
  retract('$pattern'(P,[Pattern,Classes])),!,
  assert('$bad_pattern'(P,[Pattern,Classes])),
  remove_bad_patterns(R,Solution).

/* ============================================================================================
*  computes the number uncorrectly classified models 
*  ============================================================================================*/

compute_uncorrectly_classified_models(Patterns,Error):-
  get_lynx_flag('$classification_file_name',SFileName),	
  open(SFileName,'append',SSS),
  format(SSS,"~n~n% ------------------------------------------------------------------",[]),
  format(SSS,"~n% Evaluating on training",[]),
  format(SSS,"~n% ------------------------------------------------------------------",[]),			
  format(SSS,"~n% train(ExampleID, TrueClass, PredictedClass, Probabilities, Result).~n~n",[]),			
  close(SSS),	
  '$models'(Models),
  compute_uncorrectly_classified_models1(Models,Patterns,Error,LikelihoodAll),
  !,
  count_total_models(Models,Tot),
  Likelihood is LikelihoodAll / Tot,
  open(SFileName,'append',SSS1),
  format(SSS1,"~n CLL: ~w",[Likelihood]),
  close(SSS1),	
  format("~n CLL: ~w~n",[Likelihood]).
compute_uncorrectly_classified_models1([],_,0,0).
compute_uncorrectly_classified_models1([[Class,Models]|RestModels],Patterns,Error,Likelihood):-
  compute_uncorrectly_classified_models1(RestModels,Patterns,Error1,Likelihood1),!,
  compute_uncorrectly_classified_models2(Models,Class,Patterns,Error0,Likelihood2),
  Likelihood is Likelihood1 + Likelihood2,
  Error is Error0 + Error1.

compute_uncorrectly_classified_models2([],_,_,0,0).
compute_uncorrectly_classified_models2([Model|RestModels],Class,Patterns,Error,LogLikelihood):-
	compute_uncorrectly_classified_models2(RestModels,Class,Patterns,Error1,LogLikelihood1),!,
	compute_model_probabilities(Patterns,Model,Model_probabilities),


	get_lynx_flag('$classes',Classes),
	predicted_class(Model_probabilities,Classes,Predicted_class),

	
	get_lynx_flag('$classification_file_name',ClassFileName),			
	open(ClassFileName,'append',Stream),	

	sumlist(Model_probabilities,SumL),
	divlist(Model_probabilities,SumL,Gx),

	nth(PosTrueClass,Classes,Predicted_class),
	nth(PosTrueClass,Gx,ProbTrueClass),
	LL is log(ProbTrueClass),
	LogLikelihood is LogLikelihood1 + LL,

	
  (Predicted_class \== Class ->	
	 Error is Error1 + 1,
	 format(Stream,"train(~w, ~w, ~w, ~w, incorrect).~n",[Model,Class,Predicted_class,Gx])
  ;
	 Error is Error1,
	 format(Stream,"train(~w, ~w, ~w, ~w, correct).~n",[Model,Class,Predicted_class,Gx])		
  ),
	close(Stream).


%%% compute the probability P(C|X) of a single model for each class
compute_model_probabilities([],_,ClassProb):-
  '$pclasses'(ClassProb).
compute_model_probabilities([N|RestP],Model,DEPR):-
  compute_model_probabilities(RestP,Model,Rest),
  array_element(Model, N, Prob),
  mullists(Prob,Rest,DEPR).


/* ============================================================================================
*  testing predicates
*  ============================================================================================*/

test(InputFile) :-
  atom_chars(InputFile,InputFileName),
  append(InputFileName,[.,v,a,l],ValFileName0),
  atom_chars(ValFileName,ValFileName0),
  test_models(ValFileName).

%%% evaluate each test model 
test_models(File):-
  open(File,read,Stream),
  get_lynx_flag('$classification_file_name',SFileName),	
  open(SFileName,'append',SSS),
  format(SSS,"~n~n% ------------------------------------------------------------------",[]),
  format(SSS,"~n% Evaluating on testing",[]),
  format(SSS,"~n% ------------------------------------------------------------------",[]),			
  format(SSS,"~n% test(ExampleID, TrueClass, PredictedClass, Probabilities, Result).~n~n",[]),			
  build_confusion_matrix(InitialCM),
  close(SSS),
  test_models1(Stream,Err,Seq,InitialCM,CM,_ALL,LikelihoodAll),
  Likelihood is LikelihoodAll / Seq,
  open(SFileName,'append',SSS1),
  format(SSS1,"~n~n% CLL: ~w",[Likelihood]),
  close(SSS1),	
  get_lynx_flag('$classes',Classes),
  format("~nResults~n----------------~n",[]),
  write_confusion_matrix(Classes,CM),
  format("----------------",[]),	
  Accuracy is 1.0 - (Err / Seq),
  format("~n + Models: ~w~n + Accuracy: ~w~n + CLL     : ~w~n~n",[Seq,Accuracy,Likelihood]),
  close(Stream).

test_models1(A,B,C,ICM,CM,ALL,CLL):-
  test_models1(A,0,0,B,C,ICM,CM,ALL,0,CLL).
test_models1(File,EE,NSS,E,NS,ICM,CM,[[Module,CC]|RALL],OldCLL,CLL):-
  read(File,Clause),
  Clause = begin(Module,Class),!,
  %abolish(test:p/1),
  abolish(test:m/2),	
  test_model(Module,File),
  tadd_dimensional_predicates,
  get_lynx_flag('$bkfilename',BKFileName),
  load_bk_in_module(BKFileName,test),
  maximalpatterns(NumPatterns),
  test_patterns(NumPatterns,DP),
  (DP \== []
  ->
    gx(DP,Gx00),
    sumlist(Gx00,SumL),
    divlist(Gx00,SumL,Gx),

    get_lynx_flag('$classes',Classes),
    predicted_class(Gx,Classes,CC),
    add_to_confusion_matrix(Class,CC,ICM,ICM1),

    get_lynx_flag('$classification_file_name',ClassFileName),			
    open(ClassFileName,'append',Stream),	

    (CC \== Class
    ->
      format("test(~w, ~w, ~w, ~w, incorrect).~n",[Module,Class,CC,Gx]),
      format(Stream,"test(~w, ~w, ~w, ~w, incorrect).~n",[Module,Class,CC,Gx]),		
      log_for_auc_file(Classes,Class,Gx),
      E0 is 1
    ;
      format("test(~w, ~w, ~w, ~w, correct).~n",[Module,Class,CC,Gx]),
      format(Stream,"test(~w, ~w, ~w, ~w, correct).~n",[Module,Class,CC,Gx]),		
      log_for_auc_file(Classes,Class,Gx),
      E0 is 0
    ),
    close(Stream)
  ;
    write(' unknown')
  ),

	nth(PosPredictedClass,Classes,CC),
	nth(PosPredictedClass,Gx,ProbPredictedClass),
	CLL1 is OldCLL + log(ProbPredictedClass),

	
  E1 is EE + E0,
  NS1 is NSS + 1,
  !,
  test_models1(File,E1,NS1,E,NS,ICM1,CM,RALL,CLL1,CLL).
test_models1(_,A,B,A,B,CM,CM,[],CLL,CLL).

/* ============================================================================================
*  ============================================================================================*/

log_for_auc_file([],_Predicted_class,[]).
log_for_auc_file([Class|RestClasses],True_classification,[Class_prob|Rest_probs]):-
  get_auc_filename(Class,Class_filename),
  open(Class_filename,'append',Stream),
  (Class == True_classification ->
    format(Stream, "~w 1~n",[Class_prob])
  ;
    format(Stream, "~w 0~n",[Class_prob])
  ),
  close(Stream),
  log_for_auc_file(RestClasses,True_classification,Rest_probs).


/* compute the predicted class, the class corresponding to the max probability */
predicted_class(Class_probabilities,Classes,Predicted_class):-
  predicted_class(Class_probabilities,Classes,Predicted_class,_).
predicted_class([X],[C],C,X).
predicted_class([X|R],[C|RC],CC,V):-
  predicted_class(R,RC,CC1,V1),
  (X > V1 ->
    CC = C,
    V = X
  ;
    CC = CC1,
    V = V1
  ).



count_total_models([],0).
count_total_models([[_,A]|R],TotMod):-
  count_total_models(R,TotMod1),
  length(A,L),
  TotMod is TotMod1 + L.

/* ============================================================================================
*  ============================================================================================*/


gx(X,V) :-
  gx1(X,_,_,V).

gx1(X,_TotMod,_Models,GX):-
  compute_cond_prob_all(X,T1),
  '$pclasses'(T3),
  mullists(T1,T3,GX).

compute_cond_prob_all([X],T1):-
  !,
  compute_cond_prob(X,T1).
compute_cond_prob_all([X|R],T1):-
  compute_cond_prob_all(R,T2),
  compute_cond_prob(X,T0),
  mullists(T0,T2,T1).


compute_cond_prob(X-Val,Prob):-
  compute_cond_prob1(Val,X,Prob).

compute_cond_prob1([],_X,[]).
compute_cond_prob1([P|RP],X,[P1|RP1]):-
  ( X == 0
  ->
    P1 is 1 - P
  ;
    P1 is P
  ),
  compute_cond_prob1(RP,X,RP1).


test_model(Module,File):-
  read(File,Clause),
  Clause \== end,
  !,
  assert(test:m(_,Clause)),
  test_model(Module,File).
test_model(_,_).


test_patterns(0,[]) :-
  !.
test_patterns(N,DEPR):-
  N1 is N - 1,
  test_patterns(N1,Rest),
  '$pattern'(N,[Pattern,_Classes]),
  term_variables(Pattern,Vars),
  '$pattern_probabilities'(N,DePr),
  (test_patternoi_module(Pattern,Vars)
  ->
    %	 write(DePr),
    %	 write(' '),write(N), %%%%%
    append([1-DePr],Rest,DEPR)
  ;
    append([0-DePr],Rest,DEPR)
    %	 DEPR = Rest
    ).

/* ============================================================================================
*  ============================================================================================*/

test_patternoi_module(P,V) :-
    test_patternoi_module1(P),
    (get_lynx_flag('$object_identity',true) ->
      alldiff(V)
    ;
      true
    ),
    !.
  test_patternoi_module1([]).
test_patternoi_module1([X|R]) :-
  call(test:m(_,X)),
  test_patternoi_module1(R).

/* ============================================================================================
*  ============================================================================================*/

tadd_dimensional_predicates :-
  ( current_predicate(dimension/1)
  ->
    findall(Dim, dimension(Dim), Dimensional0),
    tadd_dimensional1(Dimensional0)
  ;
    true
  ).

tadd_dimensional1([]).
tadd_dimensional1([Dim|RestDim]) :-
  atom_chars(Dim,DimChar),
  DimChar = [_,_,_,_,_|DimName0],
  append([f,o,l,l,o,w,'_'],DimName0, FollowName0),
  append([f,o,l,l,o,w,a,t,'_'],DimName0, FollowatName0),
  atom_chars(FollowName,FollowName0),
  atom_chars(FollowatName,FollowatName0),
  HeadFollow1 =.. [FollowName,A,B],
  Next11 =.. [Dim,A,B],
  assert(test:(m(Model,HeadFollow1) :- m(Model,Next11), !)),
  Next12 =.. [Dim,A,C],
  Follow2 =.. [FollowName,C,B],
  assert(test:(m(Model,HeadFollow1) :- m(Model,Next12), !, m(Model,Follow2))),
  HeadFollowat1 =.. [FollowatName,1,A,B],
  assert(test:(m(Model,HeadFollowat1) :- !, m(Model,Next11))),
  HeadFollowat2 =.. [FollowatName,N,A,B],
  Followat2 =.. [FollowatName,N1,C,B],
  assert(test:(m(Model,HeadFollowat2) :- m(Model,Next12),!, (N1 is N - 1), m(Model,Followat2))),
  tadd_dimensional1(RestDim).

/* ============================================================================================
*  ============================================================================================*/

assert_covering([]).
assert_covering([[C,M]|R]):-
  build_covering(M,M1),
  assert(covering(C,M1)),
  assert_covering(R).
build_covering([],[]).
build_covering([M|R],[M-0|R1]):-
  build_covering(R,R1).

/* ============================================================================================
*  ============================================================================================*/

assert_classes(Models):-
  extract_classes(Models,Classes),
  set_lynx_flag('$classes',Classes).
extract_classes([],[]).
extract_classes([[C,M]|R],[C|R1]):-
  length(M,L),
  assert('$classmodels'(C,L)),
  extract_classes(R,R1).
/* ============================================================================================
*  ============================================================================================*/

/* compute and assert pattern probabilities */
set_patterns_probabilities:-
  maximalpatterns(NumPatterns),
  set_patterns_probabilities(NumPatterns,_DP).

/* recompute and reassert pattern probabilities */
reset_patterns_probabilities:-
  maximalpatterns(NumPatterns),
  retractall('$pattern_probabilities'(_,_)),
  set_patterns_probabilities(NumPatterns,_DP).

set_patterns_probabilities(0,[]) :-
  !.
set_patterns_probabilities(N,[_DP|RestDP]):-
  '$pattern'(N,[_Pattern,Classes]),
  %	count_tot_freq(Classes,TotFreq),
  pattern_probabilities(Classes,Pattern_probs),
  %	sum_list(DP0,Sum),
  %	divlist(DP0,Sum,DP),
  %	nl,write(DP),
  %	assert('$pattern_probabilities'(N,DP)),
  assert('$pattern_probabilities'(N,Pattern_probs)),	
  N1 is N - 1,
  set_patterns_probabilities(N1,RestDP).

pattern_probabilities([],[]).
pattern_probabilities([[_Class,F/T,F/_IF,_Modules]|RestClasses],[D|RestD]) :-
  %	D0 is F/T,
  %	D is exp(D0),
  %log	D is (F+1)/(T+2),
  D is ((F+0.1)/(T+0.2)),
  pattern_probabilities(RestClasses,RestD).

/* ============================================================================================
*  ============================================================================================*/



% consult all sequences asserting them in separate modules

consult_models(File,Modules):-
  open(File,read,Stream),
  consult_models1(Stream,Modules),
  close(Stream).

consult_models1(File,Modules):-
  read(File,Clause),
  Clause = begin(Module,Class),!,
  consult_model(Module,File),
  consult_models1(File,Modules1),
  addlistmodule([Module,Class],Modules1,Modules).
consult_models1(_,[]).

consult_model(Module,File):-
  read(File,Clause),
  Clause \== end,
  !,
  assert(models:m(Module,Clause)),
  consult_model(Module,File).
consult_model(_,_).

addlistmodule([Module,Class],[],[[Class,[Module]]]).
addlistmodule([Module,Class],[[Class,Modules]|RestClasses],[[Class,Modules1]|RestClasses]):-
  append([Module],Modules,Modules1),!.
addlistmodule([Module,Class],[[Class1,Modules]|RestClasses],[[Class1,Modules]|RestClasses1]):-
  addlistmodule([Module,Class],RestClasses,RestClasses1).

/* ============================================================================================
*  ============================================================================================*/

/* -------------------------------------------------------------------------------------------
remove_neg_constraints/2
Rimuove dalla lista dei pattern tutti quelli che verificano un vincolo negativo
*/ 	
remove_neg_constraints(Patterns,Patterns1) :-
  findall(Constraint, negconstraint(Constraint), Constraints),
  remove_neg_constraints(Patterns,Constraints,Patterns1).
remove_neg_constraints(P,[[]],P) :- !.
remove_neg_constraints([],_Constraints,[]).
remove_neg_constraints([[Pattern,Freq]|RestPatterns],Constraints,[[Pattern,Freq]|RestPatterns1]) :-
  %copy_term(Pattern,PatternN),
  skolemize(Pattern,PatternS),
  \+ prove_constraints(Constraints,PatternS),
  !,
  remove_neg_constraints(RestPatterns,Constraints,RestPatterns1).
remove_neg_constraints([_|RestPatterns],Constraints,RestPatterns1) :-
  remove_neg_constraints(RestPatterns,Constraints,RestPatterns1).


/* ============================================================================================
*  ============================================================================================*/

/* ============================================================================================
Utilities
============================================================================================*/

/* -------------------------------------------------------------------------------------------
skolemize/2
Crea un grounding dell'insieme dei letterali List usando costanti di Skolem
*/
skolemize(List,List1) :-
  copy_term(List,List1),
  term_variables(List1,Vars),
  skolemize1(Vars,0).

skolemize1([],_).
skolemize1([V|R],N) :-
  name(N,NN),
  append("s",NN,Sk),
  name(V,Sk),
  N1 is N + 1,
  skolemize1(R,N1).


/* ============================================================================================
Pattern utilities
============================================================================================*/

/* -------------------------------------------------------------------------------------------
remove_empty/2
Remove empty patterns
*/
remove_empty([],[]).
remove_empty([[[],_]|R],R1):-
  !,
  remove_empty(R,R1).
remove_empty([X|R],[X|R1]):-
  remove_empty(R,R1).


/* -------------------------------------------------------------------------------------------
remove_general/2
*/
remove_general([],[]):-
  !.
remove_general([Pattern],[Pattern]):-
  !.
remove_general([Pattern|RestPatterns],Patterns1):-
  more_general(Pattern,RestPatterns),
  !,
  remove_general(RestPatterns,Patterns1).
remove_general([Pattern|RestPatterns],[Pattern|Patterns1]):-
  remove_general(RestPatterns,Patterns1).

more_general([Pattern,Inst],[[Pattern1,Inst1]|_Rest1]):-
  %	copy_term(Pattern,Pattern0),
  my_subsumes_chk(Pattern,Pattern1),
  equal_inst(Inst,Inst1),
  !.
more_general([Pattern,Inst],[_|Rest1]):-
  more_general([Pattern,Inst],Rest1).


my_subsumes_chk(T1,T2):-
  copy_term(T1,T11),
  copy_term(T2,T22),
  my_subsumes_chk1(T11,T22).

my_subsumes_chk1([],_T2).
my_subsumes_chk1([X|R],T2) :-
  member(X,T2),
  my_subsumes_chk1(R,T2).


equal_inst([],[]).
equal_inst([[Class,_InitialFreq,Freq,_Mods]|Rest],[[Class,_InitialFreq1,Freq,_Mods1]|Rest1]):-
  %equal_inst1(Mods,Mods1),
  equal_inst(Rest,Rest1).
equal_inst1([],[]).
equal_inst1([[SeqName,_Freq,_Tot,_Inst]|Rest],[[SeqName,_,_,_]|Rest1]):-
  equal_inst1(Rest,Rest1).

/* ============================================================================================
*  ============================================================================================*/

/* -------------------------------------------------------------------------------------------
remove_low_freq/4
Remove patterns with a low coverage value
*/

remove_low_freq([],_,_,[]).
remove_low_freq([[Pattern,Inst]|Rest],MinFreq,MinClRec,[[Pattern,Inst]|Rest1]) :-
  count_max_class_freq(Inst,MaxClFreq),
  MaxClFreq >= MinClRec,
  !,
  remove_low_freq(Rest,MinFreq,MinClRec,Rest1).
remove_low_freq([_|Rest],MinFreq,MinClRec,Rest1) :-
  remove_low_freq(Rest,MinFreq,MinClRec,Rest1).


remove_min_cov([],_MinCov,[]).
remove_min_cov([[Pattern,Freq]|Rest],MinCov,[[Pattern,Freq]|Rest1]):-
  not_min_cov(Freq,MinCov),
  !,
  remove_min_cov(Rest,MinCov,Rest1).
remove_min_cov([[_Pattern,_Freq]|Rest],MinCov,Rest1):-
  %	    format_pattern_freqs(Pattern,Freq,FPF),
  %	    retract(maximalpatterns(MaximalPatternsOld)),
  %	    MaximalPatternsNew is MaximalPatternsOld + 1,
  %	    assert(maximalpatterns(MaximalPatternsNew)),
  %	    assert('$pattern'(MaximalPatternsNew,FPF)),
  %	    add_covering(Freq),
  remove_min_cov(Rest,MinCov,Rest1).

not_min_cov(Freq,MinCov):-
  take_class_cov(Freq,[Class,_,_,Mods]),
  covering(Class,Cover),
  \+ min_cov(Mods,MinCov,Cover).

take_class_cov([[Class,InitialFreq,Freq,Mods]],[Class,InitialFreq,Freq,Mods]):-
  !.
take_class_cov([[Class,InitialFreq,Freq,Mods]|Rest],[Class0,InitialFreq0,Freq0,Mods0]):-
  take_class_cov(Rest,[Class1,InitialFreq1,Freq1,Mods1]),
  '$classmodels'(Class,L),
  F is Freq/L,
  '$classmodels'(Class1,L1),
  F1 is Freq1/L1,
  (F > F1
  ->
    Class0 = Class,
    InitialFreq0 = InitialFreq,
    Freq0 = Freq,
    Mods0 = Mods
  ;
    Class0 = Class1,
    InitialFreq0 = InitialFreq1,
    Freq0 = Freq1,
    Mods0 = Mods1
  ).

min_cov([],_,_).
min_cov([Module|RestModules],MinCov,Cover):-
  member(Module-F,Cover),
  F >= MinCov,
  min_cov(RestModules,MinCov,Cover).

add_covering(FFF):-
  take_class_cov(FFF,[Class,_InitialFreq,_Freq,Mods]),
  retract(covering(Class,Cover)),
  add_covering(Cover,Mods,Cover1),
  assert(covering(Class,Cover1)).

/*
add_covering(FFF):-
  take_class_cov(FFF,[Class,_InitialFreq,_Freq,Mods]),
  add_covering1(FFF,Class).
add_covering1([],Class).
add_covering1([[Class,_InitialFreq,_Freq,Mods]|Rest],Class):-
  !,
  retract(covering(Class,Cover)),
  add_covering(Cover,Mods,Cover1),
  assert(covering(Class,Cover1)),
  add_covering1(Rest,Class).
add_covering1([[Class1,InitialFreq,Freq,Mods]|Rest],Class):-
  retract(covering(Class1,Cover)),
  sub_covering(Cover,Mods,Cover1),
  assert(covering(Class1,Cover1)),
  add_covering1(Rest,Class).
*/
/* ============================================================================================
*  ============================================================================================*/

add_covering([],_Mods,[]).
add_covering([M-F|R],Mods,[M-F1|R1]):-
  member(M,Mods),
  !,
  F1 is F + 1,
  add_covering(R,Mods,R1).
add_covering([M-F|R],Mods,[M-F|R1]):-
  add_covering(R,Mods,R1).
/* ============================================================================================
*  ============================================================================================*/

/* ------------------------------------------------------------------------------------------- */	
/*
rimuove dalla lista dei pattern tutti quelli che hanno raggiunto la lunghezza
massima
*/
remove_max_length([],_,[]).
remove_max_length([[Pattern,Freq]|Rest],MaxSize,[[Pattern,Freq]|Rest1]) :-
  count_size(Pattern,Size),
  Size < MaxSize,
  !,
  remove_max_length(Rest,MaxSize,Rest1).
remove_max_length([[Pattern,Freq]|Rest],MaxSize,Rest1) :-
  remove_max_length(Rest,MaxSize,Rest1).


/* ============================================================================================
*  ============================================================================================*/


/* ------------------------------------------------------------------------------------------- */
get_freq_pattern([],[]).
get_freq_pattern([[C,F,IF,_]|R],[[C,F,IF]|R1]):-
  get_freq_pattern(R,R1).


/* -------------------------------------------------------------------------------------------
write_freq_pattern/1
*/
write_freq_pattern([]).
write_freq_pattern([[C,_IF,F,_]|R]):-
  '$classmodels'(C,N),
  P is F / N,
  format(" [~w: ~3f]",[C,P]),
  write_freq_pattern(R).

write_freq_pattern2([]).
write_freq_pattern2([[C,_IF/_,F/_,_]|R]):-
  '$classmodels'(C,N),
  P is F / N,
  format(" [~w: ~3f]",[C,P]),
  write_freq_pattern2(R).

/* ============================================================================================
*  ============================================================================================*/

/* ------------------------------------------------------------------------------------------- */
/*
conta il numero di letterali nel pattern escludento dal conteggio quelli
dimensionali
*/
count_size([],0).
count_size([Lit|Rest],Size) :-
  dimensional_pred(Lit),!,
  count_size(Rest,Size).
count_size([_|Rest],Size) :-
  count_size(Rest,Size1),
  Size is Size1 + 1.
/* ============================================================================================
*  ============================================================================================*/

/* ------------------------------------------------------------------------------------------- */
e_flatten([],[]).
e_flatten([A|R],R1):-
  e_flatten(R,R0),
  append(A,R0,R1).
/* ============================================================================================
*  ============================================================================================*/

/* -------------------------------------------------------------------------------------------
specialize/2
*/	
specialize(A,B):-
  e_specialize(A,B1),
  e_flatten(B1,B).

e_specialize([],[]).
e_specialize([Pattern|RestPatterns],[SpecPatterns0|SpecPatterns1]) :-
  e_specialize(RestPatterns,SpecPatterns1),
  specialize_pattern(Pattern,SpecPatterns0).	


%specialize_pattern(Pattern,SpecPatterns) :-
%  	/* se il pattern contiene solo la chiave non specializzo con letterali dimensionali */
%  	key(Keys),
%  	Pattern = [[Key],_Inst],
%  	member(Key, Keys),
%  	!,
%  	specialize_with_nodim(Pattern,SpecPatterns).
specialize_pattern(Pattern,SpecPatterns) :-
  specialize_with_dim(Pattern,SpecPatternsDim),
  specialize_with_nodim(Pattern,SpecPatternsNoDim),
  append(SpecPatternsDim,SpecPatternsNoDim,SpecPatterns),!.

/*specialize_pattern(Pattern,SpecPatterns) :-
  % specializza prima tutti con un dimensionale 
  specialize_with_dim(Pattern,SpecPatternsDim0),
  % specializza i precedenti con un non dimensionale 
  specialize_patterns_with_nodim(SpecPatternsDim0,SpecPatternsDim),
  % poi specializza solo con non dimensionali 
  specialize_with_nodim(Pattern,SpecPatternsNoDim),
  append(SpecPatternsDim,SpecPatternsNoDim,SpecPatterns).
*/




/*
specializza con letterali dimensionali
*/
specialize_with_dim([Pattern,Inst],SpecPatternsDim) :-
  extract_events_fordim(Pattern,Events),
  extract_events_fornodim(Pattern,Events1),
  length(Events,LE),
  length(Events1,LE1),
  UnboudEvents is LE1 - LE,
  ( UnboudEvents == 0 ->
    '$dimensionals'(Dimensionals),
    specialize_with_dim0(Dimensionals,[Pattern,Inst],Events,SpecPatternsDim)
  ;
    SpecPatternsDim = []
  ).

specialize_with_dim0(A,Pattern,Events,B):-
  e_specialize_with_dim0(A,Pattern,Events,B1),
  e_flatten(B1,B).

e_specialize_with_dim0([],_Pattern,_Events,[]).
e_specialize_with_dim0([Dimensionals|RestDimensionals],Pattern,Events,[SpecPatternsDim1|SpecPatternsDim0]) :-
  e_specialize_with_dim0(RestDimensionals,Pattern,Events,SpecPatternsDim0),
  specialize_with_dim1(Dimensionals,Pattern,Events,SpecPatternsDim1).

specialize_with_dim1(A,Pattern,Events,B):-
  e_specialize_with_dim1(A,Pattern,Events,B1),
  e_flatten(B1,B).


e_specialize_with_dim1([],_Pattern,_Events,[]).
e_specialize_with_dim1([DimPred|RestDims],Pattern,Events,[SpecPatternsDim0|SpecPatternsDim1]) :-
  e_specialize_with_dim1(RestDims,Pattern,Events,SpecPatternsDim1),
  specialize_with_dim2(Events,DimPred,Pattern,SpecPatternsDim0).


specialize_with_dim2([],_DimPred,_Pattern,[]).
specialize_with_dim2([Event|RestEv],DimPred/2,[Pattern,Inst],NewPatterns) :-
  Pred =.. [DimPred|[Event,_]],
  %	Pred1 =.. [DimPred|[_,Event]],
  ( compatible_dim(Pattern,Event,Pred) ->
    append(Pattern,[Pred],NewPattern1)
    %	  (compatible_dim(Pattern,Event,Pred1) ->
    %	   append(Pattern,[Pred1],NewPattern2)
    %	  ;
    %	   NewPattern2 = []
    %	  )
    ;
      NewPattern1 = []%,
      %	  (compatible_dim(Pattern,Event,Pred1) ->
      %	   append(Pattern,[Pred1],NewPattern2)
      %	  ;
      %	   fail
      %	  )
      ),
      !,
      specialize_with_dim2(RestEv,DimPred/2,[Pattern,Inst],NewPatterns1),
      append([[NewPattern1,Inst]],NewPatterns1,NewPatterns).
    %	append([[NewPattern1,Inst]],[[NewPattern2,Inst]],NewPattern3),
    %	append(NewPattern3,NewPatterns1,NewPatterns).
    /* specializzo con il followat */
    specialize_with_dim2([Event|RestEv],DimPred/3,[Pattern,Inst],RestPred1) :-
      get_lynx_flag('$maxfollowat', MaxFollowat),
      specialize_with_dim3(Event,MaxFollowat,DimPred/3,[Pattern,Inst],NewPatternsSpec),
      specialize_with_dim2(RestEv,DimPred/3,[Pattern,Inst],RestPred),
      append(NewPatternsSpec,RestPred,RestPred1).
    specialize_with_dim2([_|RestEv],DimPred,Pattern,RestPred) :-
      specialize_with_dim2(RestEv,DimPred,Pattern,RestPred).

    specialize_with_dim3(_Event,1,_DimPred,_,[]):-
      !.
    specialize_with_dim3(Event,MaxFollowat,DimPred/3,[Pattern,Inst],[[NewPattern,Inst]|NewPatternsSpec]) :-
      Pred =.. [DimPred|[MaxFollowat,Event,_]],
      compatible_dim(Pattern,Event,Pred),
      !,	
      append(Pattern,[Pred],NewPattern),
      MaxFollowat1 is MaxFollowat - 1,
      specialize_with_dim3(Event,MaxFollowat1,DimPred/3,[Pattern,Inst],NewPatternsSpec).
    specialize_with_dim3(_Event,_MaxFollowat,_,_,[]).


  compatible_dim([],_,_).
compatible_dim([Lit|Rest],Event,Pred) :-
  dimensional_pred(Lit),
  same_dimension(Lit,Pred),!,
  compatible_dim(Lit,Pred),
  compatible_dim(Rest,Event,Pred).
compatible_dim([_Lit|Rest],Event,Pred) :-
  compatible_dim(Rest,Event,Pred).


compatible_dim(Lit1,Lit2) :-
  Lit1 =.. [_|Args1],
  Lit2 =.. [_|Args2],
  alldiffeq(Args1,Args2).
/* ============================================================================================
*  ============================================================================================*/

/* per next e follow */
alldiffeq([A,B],[A1,B1]) :-
  A \== A1, B \== B1.
/* per followat */
alldiffeq([_,A,B],[_,A1,B1]):-
  A \== A1, B \== B1.

alldiffeq([A,B],[_,A1,B1]) :-
  A \== A1, B \== B1.
alldiffeq([_,A1,B1],[A,B]) :-
  A \== A1, B \== B1.
/* ============================================================================================
*  ============================================================================================*/

specialize_with_nodim([Pattern,Inst],SpecPatternsNoDim) :-
  extract_last_subpattern(Pattern,SubPattern),
  extract_events_fornodim(Pattern,Events),
  extract_objects(SubPattern,Events,Objects),
  extract_objects(Pattern,Events,AllObjects),
  specialize_with_fluents([Pattern,Inst],Events,AllObjects,FluntsSpec),
  specialize_with_nofluents([Pattern,Inst],Events,Objects,NoFluntsSpec),
  append(FluntsSpec,NoFluntsSpec,SpecPatternsNoDim).

extract_last_subpattern(Pattern,SubPattern):-
  extract_last_subpattern(Pattern,[],SubPattern).

extract_last_subpattern([],SubPattern,SubPattern).
extract_last_subpattern([Lit|Rest],_Old,SubPattern):-
  dimensional_pred(Lit),!,
  extract_last_subpattern(Rest,[Lit],SubPattern).
extract_last_subpattern([Lit|Rest],Old,SubPattern):-
  append(Old,[Lit],New),
  extract_last_subpattern(Rest,New,SubPattern).

specialize_with_fluents(Pattern,Events,Objects,FluntsSpec) :-
  '$fluents'(Fluents),
  specialize_with_fluents(Fluents,Pattern,Events,Objects,FluntsSpec).

specialize_with_fluents(A,Pattern,Events,Objects,B):-
  e_specialize_with_fluents(A,Pattern,Events,Objects,B1),
  e_flatten(B1,B).

e_specialize_with_fluents([],_Pattern,_Events,_Objects,[]).
e_specialize_with_fluents([Pred/Arity|RestFluents],Pattern,Events,Objects,[SpecPatterns|RestFluentsSpec0]) :-
  functor(FluentType,Pred,Arity),
  functor(FluentMode,Pred,Arity),
  det_type(FluentType),
  det_mode(FluentMode),
  FluentType =.. [_|TypeArgs],
  FluentMode =.. [_|ModeArgs],
  findall(SpecPattern , one_spec_lit(TypeArgs,ModeArgs,Events,Objects,Pred/Arity,Pattern,SpecPattern), SpecPatterns),
  !,
  e_specialize_with_fluents(RestFluents,Pattern,Events,Objects,RestFluentsSpec0).
/* ============================================================================================
*  ============================================================================================*/

det_type(A):-
  type(A),
  !.

det_mode(A):-
  mode(A),
  !.

specialize_with_nofluents(Pattern,Events,Objects,NoFluntsSpec) :-
  '$nofluents'(NoFluents),
  specialize_with_fluents(NoFluents,Pattern,Events,Objects,NoFluntsSpec).


/* ============================================================================================
*  ============================================================================================*/

ttt(SpecLit) :-
  copy_term(SpecLit,SLit1),
  v(SLit1),
  !.
/* ============================================================================================
*  ============================================================================================*/

some_ground([X|_R]):-
  ground(X),
  !.
some_ground([_X|R]):-
  some_ground(R).

/* ============================================================================================
*  ============================================================================================*/

one_spec_lit(TypeArgs,ModeArgs,Events,Objects,Pred/_Arity,[Pattern,Inst],[SpecPattern,Inst1]) :-
  %  format("\n - ~w",[Pred]),	
  nground_events_objects(TypeArgs,ModeArgs,NEvents,_NObjects),
  lasts(Events,NEvents,Events1),
  %	lasts(Objects,NObjects,Objects1),
  %	take_args(TypeArgs,ModeArgs,Events1,Objects1,Args),

  %%	rem_consts(Objects,ObjectsWOC), %%% TODO

  take_args(TypeArgs,ModeArgs,Events1,Objects,Args),
  SpecLit =.. [Pred|Args],

  ( some_ground(Args) ->
    ttt(SpecLit)
  ;
    true
  ),

  %	\+ all_vars(Args),
  %	\+ some_vars(Args),
  %	nl,portraylist([SpecLit|Pattern]),
  \+ member_eq(SpecLit,Pattern), %write('!'),flush_output,
  %	last(Pattern,LastLit),
  %	LastLit =.. [Predicate1|Arguments1],
  %	SpecLit =.. [Predicate2|Arguments2],
  %	last(Arguments1,LastA1),
  %	last(Arguments2,LastA2),
  %	term_variables(Pattern,Vars),
  %	nth_eq(LastA1,Vars,N1),
  %	nth_eq(LastA2,Vars,N2),	
  %	\+ (N2 @< N1),
  checktypes([SpecLit|Pattern]),%	   	   write('!'),
  \+ checksametype(SpecLit,Pattern),% write('!'),
  \+ checkonlyone(SpecLit,Pattern),%write('!'),		flush_output,
  append(Events,Objects,All),
  linked(Args,All),
  append(Pattern,[SpecLit],SpecPattern),
  remove_neg_constraints([[SpecPattern,_]],[[SpecPattern,_]]),

  prove_patterns_for_classes(SpecPattern,Inst,Inst1),
  count_max_class_freq(Inst1,MaxClFreq), 
  get_lynx_flag('$minclassrecall', MinClRec),
  MinClRec =< MaxClFreq,
  ( get_lynx_flag('$lynx_verbose', 0)
  ->
    true
  ;
    nl,write(' * pattern '), portraylist(SpecPattern),write_freq_pattern(Inst1)
  ).


/* ============================================================================================
*  ============================================================================================*/

/* ------------------------------------------------------------------------------------------- */	
/* controlla che le stesse variabili utilizzate nel pattern in più letterali siano dello stesso tipo */
checktypes(Pattern):-
  copy_term(Pattern,P1),
  checktypes1(P1),
  !.
checktypes1([]).
checktypes1([X|R]):-
  X =.. [Pred|Args],
  length(Args,LArgs),
  length(Args1,LArgs),
  X1 =.. [Pred|Args1],
  type(X1),
  checktypes2(Args,Args1),
  checktypes1(R).

checktypes2([],[]).
checktypes2([X|R],[X1|R1]):-
  var(X),
  !,
  X = '$t'(X1),
  checktypes2(R,R1).
checktypes2([X|R],[X1|R1]):-
  X = '$t'(A),
  !,
  A = X1,
  checktypes2(R,R1).
checktypes2([_X|R],[_X1|R1]):-
  checktypes2(R,R1).

/* ============================================================================================
*  ============================================================================================*/

/* ------------------------------------------------------------------------------------------- */	
/* lasts(List,k,List1) estrae dalla lista List gli ultimi k elementi*/
lasts([],_K,[]) :- !.
lasts(List,K,List1):-
  reverse(List,List0),
  lasts1(List0,K,List1).
lasts1(_List0,0,[]):-
  !.
lasts1([X|R],K,[X|R1]) :-
  K1 is K - 1,
  lasts1(R,K1,R1).
/* ============================================================================================
*  ============================================================================================*/

/* ------------------------------------------------------------------------------------------- */	
/* conta il numro di eventi ed oggetti ground necessari */
nground_events_objects([],[],0,0).
nground_events_objects([e|RestArgs],[+|RestMode],GroundEvents,GroundObjects) :-
  !,
  nground_events_objects(RestArgs,RestMode,GroundEvents1,GroundObjects),
  GroundEvents is GroundEvents1 + 1.
nground_events_objects([e|RestArgs],[#|RestMode],GroundEvents,GroundObjects) :-
  !,
  nground_events_objects(RestArgs,RestMode,GroundEvents1,GroundObjects),
  GroundEvents is GroundEvents1 + 1.
nground_events_objects([_Arg|RestArgs],[+|RestMode],GroundEvents,GroundObjects) :-
  !,
  nground_events_objects(RestArgs,RestMode,GroundEvents,GroundObjects1),
  GroundObjects is GroundObjects1 + 1.
nground_events_objects([_Arg|RestArgs],[#|RestMode],GroundEvents,GroundObjects) :-
  !,
  nground_events_objects(RestArgs,RestMode,GroundEvents,GroundObjects1),
  GroundObjects is GroundObjects1 + 1.
nground_events_objects([_Arg|RestArgs],[_Mode|RestMode],GroundEvents,GroundObjects) :-
  nground_events_objects(RestArgs,RestMode,GroundEvents,GroundObjects).
/* ============================================================================================
*  ============================================================================================*/

/* ============================================================================================
Constraints checker
============================================================================================*/

/* ------------------------------------------------------------------------------------------- */	
checkonlyone(Lit, Pattern) :-
  ( current_predicate(onlyone/1)
  ->
    onlyone(OnlyOneLits),
    member(Lit, OnlyOneLits),
    !,
    checkonlyone1(OnlyOneLits, Pattern)
  ;
    fail
  ).

checkonlyone1([Lit|_RestLit],Pattern) :-
  member(Lit,Pattern),!.
checkonlyone1([_|RestLit],Pattern) :-
  checkonlyone1(RestLit,Pattern).

/* ------------------------------------------------------------------------------------------- */	
checksametype(Lit, Pattern) :-
  (current_predicate(sametype/1)
  ->
    sametype(SameTypeLits),
    membertype(SameTypeLits,Lit),
    !,
    sametype(SameTypeLits,Pattern)
  ;
    fail
  ).

sametype([Lit|_RestLit],Pattern) :-
  member_eq(Lit,Pattern),!.
sametype([_|RestLit],Pattern) :-
  sametype(RestLit,Pattern).
membertype([Lit|_Rest],Lit1):-
  Lit = Lit1.
membertype([_|Rest],Lit):-
  membertype(Rest,Lit).

/* ============================================================================================
*  ============================================================================================*/

/* ============================================================================================
Literal utilities
============================================================================================*/

/* ------------------------------------------------------------------------------------------- */	
linked([X|_R],L) :-
  member_eq_l(X,L),
  !.
linked([_|R],L) :-
  linked(R,L).

member_eq_l(X,[Y|_List]) :-
  X == Y.
member_eq_l(X,[Y-_|_List]) :-
  X == Y.
member_eq_l(X,[_|List]) :-
  member_eq_l(X,List).


/* ============================================================================================
*  ============================================================================================*/

/* ------------------------------------------------------------------------------------------- */	
take_args([],_,_Events,_Objects,[]).
take_args([Type|R],[#|RestMode],Events,Objects,[Arg|R1]) :-
  take_args(R,RestMode,Events,[Arg-Type|Objects],R1).
%take_args([_|R],[-|RestMode],Events,Objects,[_Arg|R1]) :-
%	!,
%	take_args(R,RestMode,Events,Objects,R1).
take_args([e|R],[_|RestMode],Events,Objects,[Arg|R1]) :-
  member(Arg,Events), 
  take_args(R,RestMode,Events,Objects,R1).
take_args([X|R],[_|RestMode],Events,Objects,[Arg|R1]) :-
  X \== e,
  member(Arg-X,Objects),
  take_args(R,RestMode,Events,Objects,R1).
take_args([X|R],[_|RestMode],Events,Objects,[Arg|R1]) :-
  X \== e,
  values(X,Values),
  member(Arg,Values),
  take_args(R,RestMode,Events,Objects,R1).

/* ============================================================================================
*  ============================================================================================*/

/* ------------------------------------------------------------------------------------------- */	
extract_objects(Pattern,Events,Objects) :-
  extract_all_terms(Pattern,AllVars),
  remove_eq(AllVars,Events,Objects).

extract_all_terms([],[]).
extract_all_terms([T|R],Terms):-
  T =.. [Pred|TermsT],
  length(TermsT,Lt),
  length(Types,Lt),
  T1 =.. [Pred|Types],
  type(T1),
  estract_all_terms1(Types,TermsT,TermsT0),
  extract_all_terms(R,Terms1),
  insert_eq(TermsT0,Terms1,Terms).


insert_eq([], List, List).
insert_eq([X|R], List, List1):-
  member_eq(X,List),
  !,
  insert_eq(R, List, List1).
insert_eq([X|R], List, [X|List1]):-
  insert_eq(R, List, List1).


estract_all_terms1([],[],[]).
estract_all_terms1([Type|RestTypes],[Term|RestTerm],[Term-Type|RestTerm1]):-
  var(Term),
  !,
  estract_all_terms1(RestTypes,RestTerm,RestTerm1).
estract_all_terms1([_Type|RestTypes],[_Term|RestTerm],RestTerm1):-
  estract_all_terms1(RestTypes,RestTerm,RestTerm1).

/* ============================================================================================
*  ============================================================================================*/


/* ------------------------------------------------------------------------------------------- */	
remove_eq([],_,[]).
remove_eq([X|R],List,R1) :-
  member_eq(X,List),!,
  remove_eq(R,List,R1).
remove_eq([X|R],List,[X|R1]) :-
  remove_eq(R,List,R1).

/* ------------------------------------------------------------------------------------------- */	
member_eq(X,[Y|_List]) :-
  X == Y.
member_eq(X,[_|List]) :-
  member_eq(X,List).
/* ============================================================================================
*  ============================================================================================*/

/* ------------------------------------------------------------------------------------------- */	
extract_events_fordim(Pattern,Events) :-
  extract_events_fordim1(Pattern,Events1),
  remove_duplicates(Events1,Events).
extract_events_fornodim(Pattern,Events) :-
  extract_events_fornodim1(Pattern,Events1),
  remove_duplicates(Events1,Events).

extract_events_fordim1([],[]).
extract_events_fordim1([Lit|RestLits],Events) :-
  dimensional_pred(Lit),!,
  extract_events_fordim1(RestLits,Events).
extract_events_fordim1([Lit|RestLits],RestE) :-
  Lit =.. [Pred|Args],
  fluent_pred(Pred),!,
  length(Args,LArgs),
  length(Args1,LArgs),
  Fpred =.. [Pred|Args1],
  type(Fpred),
  extract_events2(Args1,Args,Events),
  extract_events_fordim1(RestLits,RestE0),
  append(Events,RestE0,RestE).
extract_events_fordim1([_Lit|RestLits],RestE) :-
  extract_events_fordim1(RestLits,RestE).

extract_events_fornodim1([],[]).
extract_events_fornodim1([Lit|RestLits],Events) :-
  dimensional_pred(Lit),!,
  Lit =.. [_|Args],
  functor(Lit,P,A),
  extract_dim_events(P/A,Args,Events0),
  extract_events_fornodim1(RestLits,Events1),
  append(Events0,Events1,Events).
extract_events_fornodim1([Lit|RestLits],RestE) :-
  Lit =.. [Pred|Args],
  fluent_pred(Pred),!,
  length(Args,LArgs),
  length(Args1,LArgs),
  Fpred =.. [Pred|Args1],
  type(Fpred),
  extract_events2(Args1,Args,Events),
  extract_events_fornodim1(RestLits,RestE0),
  append(Events,RestE0,RestE).
extract_events_fornodim1([_Lit|RestLits],RestE) :-
  extract_events_fornodim1(RestLits,RestE).

extract_dim_events(_/2,Args,Args).
extract_dim_events(_/3,[_|Args],Args).




extract_events2([],_Args,[]).
extract_events2([e|R],[E|ER],[E|ER1]) :-
	!,
  extract_events2(R,ER,ER1).
extract_events2([_|R],[_|ER],ER1) :-
  extract_events2(R,ER,ER1).

/* ============================================================================================
*  ============================================================================================*/

/* ------------------------------------------------------------------------------------------- */	
fluent_pred(Pred) :-
  '$fluents'(Fluents),
  member(Pred/_,Fluents),!.
/* ============================================================================================
*  ============================================================================================*/

/* ------------------------------------------------------------------------------------------- */	
dimensional_pred(Pred0) :-
  copy_term(Pred0,Pred),
  '$dimensionals'(Dimensionals),
  functor(Pred,P,A),
  dimensional_pred(P/A,Dimensionals).
dimensional_pred(Pred,[Dimensionals|_Rest]) :-
  member(Pred,Dimensionals),!.
dimensional_pred(Pred,[_Dimensionals|Rest]) :-
  dimensional_pred(Pred,Rest).

/* ------------------------------------------------------------------------------------------- */	
same_dimension(Lit,Lit1) :-
  '$dimensionals'(Dimensionals),
  functor(Lit,P,A),
  functor(Lit1,P1,A1),
  same_dimension(P/A,P1/A1,Dimensionals).
same_dimension(P,P1,[Dimensionals|_R]) :-
  member(P,Dimensionals),
  member(P1,Dimensionals),!.
same_dimension(P,P1,[_Dimensionals|R]) :-
  same_dimension(P,P1,R).

/* ============================================================================================
*  ============================================================================================*/


/* -------------------------------------------------------------------------------------------
initial_patterns_frequencies/2
Calcola la frequenza dei pattern iniziali costituiti da un solo letterale
*/	

initial_patterns_frequencies([],[]).
initial_patterns_frequencies([P|R],[[P,Frequencies]|R1]) :-
  prove_initial_patterns(P,Frequencies),
  ( get_lynx_flag('$lynx_verbose', 0)
  ->
    true
  ;
    nl,write(' * pattern '), portraylist(P),	%write(' - '),write(Frequencies)
    write_freq_pattern(Frequencies)
  ),
  initial_patterns_frequencies(R,R1).


/* ------------------------------------------------------------------------------------------- */	
save_contrasting_patterns(Patterns):-
	get_lynx_flag('$minclassrecall', MinClRec),
	get_lynx_flag('$fileout',StreamOut),
	save_contrasting_patterns(Patterns,MinClRec,StreamOut).
save_contrasting_patterns([],_MinClRec,_StreamOut).
save_contrasting_patterns([[P,Inst]|R],MinClRec,StreamOut):-
      last(P,LastPredicate),
      ( \+ dimensional_pred(LastPredicate) ->
	calculate_discr_score(Inst,Maxs),
	( check_discr_score(Maxs,MinClRec) 	->	  
	  format_pattern_freqs(P,Inst,FFPP),
	  FFPP = [_,FFPPP],
	  get_freq_pattern(FFPPP,FFPPPP),
	  (get_lynx_flag('$lynx_verbose', 0) ->
	    true
	  ;
	    format("\n  -->  ",[]),
	    portraylist(P),		
	    format(" ~w ~w",[FFPPPP,Maxs])
	  ),
	  portraylist(StreamOut,P),format(StreamOut," ~w~n",[FFPPPP]),
	  flush_output,
	  save_pattern(FFPP,Inst)
	;
	  true
	)
      ;
	true
      ),
      save_contrasting_patterns(R,MinClRec,StreamOut).

check_discr_score(Maxs,MinClRec):-
      min_list(Maxs,Min),
      max_list(Maxs,Max),
      Min < Max,
      Max > MinClRec.

/* ============================================================================================
*  ============================================================================================*/

    /* ------------------------------------------------------------------------------------------- */	
    save_pattern(FPF,FFF):-
      retract(maximalpatterns(MaximalPatternsOld)),
      MaximalPatternsNew is MaximalPatternsOld + 1,
      (get_lynx_flag('$lynx_verbose', 0) ->
	true
      ;
	format(" (P ~w)",[MaximalPatternsNew])
      ),
      assert(maximalpatterns(MaximalPatternsNew)),
      assert('$pattern'(MaximalPatternsNew,FPF)),
      add_covering(FFF).


  /* -------------------------------------------------------------------------------------------
  count_max_class_freq/2
  It returns the best support over the classes
  */	
  count_max_class_freq([],0).
count_max_class_freq([[Class,_InitialFreq,Freq,_Inst]|RestClass],MaxClFreq):-
  count_max_class_freq(RestClass,MaxClFreq0),
  '$classmodels'(Class,N),
  Freq1 is Freq / N,
  ( MaxClFreq0 > Freq1 ->
    MaxClFreq = MaxClFreq0
  ;
    MaxClFreq = Freq1
  ).
/* ============================================================================================
*  ============================================================================================*/

/* trova le due frequenze massime f1 e f2  */
/* da modificare perché funziona solo con due classi */
/* ------------------------------------------------------------------------------------------- */	
calculate_discr_score([],[]).
calculate_discr_score([[Class1,_,FreqC1,_]|RestClasses],[Freq|RestFreqs]):-
  '$classmodels'(Class1,N1),
  Freq is FreqC1 / N1,
  calculate_discr_score(RestClasses,RestFreqs).

/*
format
[Pattern,[[Class,InitialFreq,Freq,[[SeqName,Freq,Tot,Inst],...]],...]]
*/
/* ============================================================================================
*  ============================================================================================*/

/* ------------------------------------------------------------------------------------------- */	
format_pattern_freqs(Pattern,Freq,[Pattern,Freqs]):-
  format_pattern_freqs1(Freq,Freqs).

format_pattern_freqs1([],[]).
format_pattern_freqs1([[Class,IF,F,Modules]|RestClass],[[Class,F/T,F/IF,Modules]|RestClassFreqs]):-
  '$classmodels'(Class,T),
  format_pattern_freqs1(RestClass,RestClassFreqs).

/* ============================================================================================
*  ============================================================================================*/

/* ------------------------------------------------------------------------------------------- */	
create_initial_patterns(_,Patterns) :-
  key(Keys),
  create_initial_patterns1(Keys,Patterns).

create_initial_patterns1([],[]).
create_initial_patterns1([Pattern|RestFluent],InitalPatterns) :-
  create_initial_patterns1(RestFluent,InitalPatterns1),
  grounds(Pattern,Grounds0),
  remove_all_vars(Grounds0,Grounds),
  append([Pattern],Grounds,Patt1),
  in_list(Patt1,Patt2),
  append(Patt2,InitalPatterns1,InitalPatterns).
/* ============================================================================================
*  ============================================================================================*/

remove_all_vars([],[]).
remove_all_vars([L|R],R1):-
  L =.. [_|Args],
  all_vars(Args),
  !,
  remove_all_vars(R,R1).
remove_all_vars([L|R],[L|R1]):-
  remove_all_vars(R,R1).

all_vars([]).
all_vars([V|R]):-
  var(V),
  all_vars(R).


/* ------------------------------------------------------------------------------------------- */	
in_list([],[]).
in_list([X|R],[[X]|R1]):-
  in_list(R,R1).

/* ------------------------------------------------------------------------------------------- */	
grounds(Predicate,Grounds):-
  copy_term(Predicate,P1),
  type(P1),
  P1 =.. [_|Types],
  take_values(Types,Values),
  \+ all_empty_values(Values),
  !,
  grounds(Predicate,Values,Grounds).
grounds(_Predicate,[]).

all_empty_values([]).
all_empty_values([[]|R]):-
  all_empty_values(R).

grounds(Predicate,Values,Grounds):-
  grounds([Predicate],Values,1,Grounds).

grounds(Grounds,[],_,Grounds).
grounds(Grounds,[[]],_,Grounds).
grounds(Predicates,[Values|RestValues],N,Grounds):-
  grounds1(Predicates,Values,N,Grounds1),
  N1 is N + 1,
  append(Predicates,Grounds1,Grounds2),
  grounds(Grounds2,RestValues,N1,Grounds).

grounds1(Grounds,[],_N,Grounds) :-
  !.
grounds1([],_Values,_N,[]).
grounds1([Predicate|RestPredicates],Values,N,Grounds):-
  grounds2(Predicate,Values,N,Grounds0),
  grounds1(RestPredicates,Values,N,Grounds1),
  append(Grounds0,Grounds1,Grounds).

grounds2(_Predicate,[],_N,[]).
grounds2(Predicate,[Value|RestValues],N,[Ground|RestGrounds]) :-
  copy_term(Predicate,Ground),
  Ground =.. [_|Args],
  nth(N,Args,V),
  V = Value,
  grounds2(Predicate,RestValues,N,RestGrounds).

take_values([],[]).
take_values([Type|RestTypes],[Values|RestValues]):-
  values(Type,Values),
  !,
  take_values(RestTypes,RestValues).
take_values([_Type|RestTypes],[[]|RestValues]):-
  take_values(RestTypes,RestValues).


predicate_type([], [], []).
predicate_type([Pred|Rest], [P/NArgs|RFluent], NoFluent) :-
  Pred =.. [P|Args],
  member(e,Args),!,
  length(Args,NArgs),
  predicate_type(Rest, RFluent, NoFluent).
predicate_type([Pred|Rest], Fluent, [P/NArgs|RNoFluent]) :-
  Pred =.. [P|Args],
  length(Args,NArgs),
  predicate_type(Rest, Fluent, RNoFluent).

/* ------------------------------------------------------------------------------------------- */	
dimensional_predicates(Dimensional) :-
  ( current_predicate(dimension/1)
  ->
    findall(Dim, dimension(Dim), Dimensional0),
    create_dimensional(Dimensional0, Dimensional)
  ;
    format(user_error,'~nNo dimensional predicates.~2n',[]),
    Dimensional = []
  ).
/* ============================================================================================
*  ============================================================================================*/

/* ------------------------------------------------------------------------------------------- */	
create_dimensional([], []).
create_dimensional([Dim|RestDim], [[Dim/2,FollowName/2,FollowatName/3]|RestDims]) :-
  atom_chars(Dim,DimChar),
  DimChar = [_,_,_,_,_|DimName0],
  append([f,o,l,l,o,w,'_'],DimName0, FollowName0),
  append([f,o,l,l,o,w,a,t,'_'],DimName0, FollowatName0),
  atom_chars(FollowName,FollowName0),
  atom_chars(FollowatName,FollowatName0),
  HeadFollow1 =.. [FollowName,A,B],
  Next11 =.. [Dim,A,B],
  assert(models:(m(Module,HeadFollow1) :- m(Module,Next11),!)),
  Next12 =.. [Dim,A,C],
  Follow2 =.. [FollowName,C,B],
  assert(models:(m(Module,HeadFollow1) :- m(Module,Next12),!, m(Module,Follow2))),
  HeadFollowat1 =.. [FollowatName,1,A,B],
  assert(models:(m(Module,HeadFollowat1) :- !, m(Module,Next11))),
  HeadFollowat2 =.. [FollowatName,N,A,B],
  Followat2 =.. [FollowatName,N1,C,B],
  assert(models:(m(Module,HeadFollowat2) :- m(Module,Next12),!, (N1 is N - 1), m(Module,Followat2))),
  NEXT =.. [Dim,e,e],
  FOLLOW =.. [FollowName,e,e],
  FOLLOWAT =.. [FollowatName,_,e,e],
  assert(type(NEXT)),
  assert(type(FOLLOW)),
  assert(type(FOLLOWAT)),
  create_dimensional(RestDim, RestDims).


/* ============================================================================================
*  Load the background knowledge 
*  ============================================================================================*/

load_bk_in_module(Bk_file, Module):-
  open(Bk_file,'read',Stream),
  read(Stream, Clause),
  load_bk_in_module(Clause,Stream,Module),
  close(Stream).
load_bk_in_module(Clause,_Stream,_Module):-
  Clause == end_of_file,
  !.
load_bk_in_module((Head :- Body),Stream,Module):-
  !,
  convert_body_bk_clause(Body,Model,Body_converted),
  assert(Module:((m(Model,Head):-Body_converted))),
  read(Stream,Clause),
  load_bk_in_module(Clause,Stream,Module).
load_bk_in_module(Head,Stream,Module):-
  assert(Module:m(_,Head)),
  read(Stream,Clause),
  load_bk_in_module(Clause,Stream,Module).

convert_body_bk_clause((A,B),Model,(A,B1)):-
  predicate_property(A,built_in),
  !,
  convert_body_bk_clause(B,Model,B1).
convert_body_bk_clause((A,B),Model,(A1,B1)):-
  A1 = m(Model,A),
  convert_body_bk_clause(B,Model,B1).
convert_body_bk_clause(A,Model,A):-
  predicate_property(A,built_in),
  !.
convert_body_bk_clause(A,Model,A1):-
  A1 = m(Model,A).


:- menu.
